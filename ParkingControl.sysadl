Model SysADLModel ; package SysADL.types { value type Int { } value type Boolean { } value type String { } value type Void { } value type Real { } enum PaymentOption { Cash , PIX , Debit , Credit , App } datatype Command { attributes : command : CommandGate ; } enum CommandGate { Open , Closed } value type DateTime { } datatype Ticket { attributes : vehicle : Vehicle ; entryTime : DateTime ; validatedUntil : DateTime ; status : PaymentStatus ; isActive : Boolean ; id : String ; } datatype Vehicle { attributes : plate : String ; driver : Driver ; isParked : Boolean ; } datatype Driver { attributes : id : String ; } enum PaymentStatus { PAID , NOT_PAID } datatype ParkingSpot { attributes : isParked : Boolean ; id : String ; isCovered : Boolean ; } datatype SpotIndication { attributes : spotsFree : Int ; spotsOccupied : Int ; } datatype Payment { attributes : ticket : Ticket ; id : String ; paymentOption : PaymentOption ; } } package ParkingControlComponents { import SysADL.types ; import ParkingControlPorts ; import ParkingControlConnectors ;
	component def SpaceSensorCP { ports : isParked : ParkingSpotOPT ; }
	component def SpaceIndicatorCP { ports :  spotsParked : SpotsIndicationIPT ; } boundary
	component def TicketReaderCP { ports : ticket : TicketOPT ; } boundary
	component def GateCP { ports : gate : CommandIPT ; component def gateControllerCP { } }
	component def DriverControllerCP { ports : driver : DriverINOUT ; newDriver : DriverIPT ; }
	component def PaymentControllerCP { } component def DriverAppInterfaceCP { ports : newDriver : DriverOPT ; } boundary
	component def FaceRecognizerCP { ports : driver : DriverOPT ; driver : DriverINOUT ; } component def ParkingControl { configuration { } }
	component def SpaceControllerCP { configuration { components : SpaceIndicatorCP : SpaceIndicatorCP { using ports : spotsParked : SpotsIndicationIPT ; } SpaceSensorCP : SpaceSensorCP { using ports : isParked : ParkingSpotOPT ; } OccupiedSpacesController : OccupiedSpacesController { using ports : isParked : ParkingSpotIPT ; spotsParked : SpotsIndicationOPT ; } } } component def OccupiedSpacesController { ports : isParked : ParkingSpotIPT ; spotsParked : SpotsIndicationOPT ; }
	component def GateControllerCP { ports : ticket : TicketIPT ; driver : DriverIPT ; gate : CommandOPT ; configuration { components : TicketCheckerCP : TicketCheckerCP { using ports : ticket : TicketIPT ; ticketCheck : TicketCheckOut ; } FaceCheckerCP : FaceCheckerCP { using ports : driver : DriverIPT ; faceCheck : FaceCheckOut ; } GateCommanderCP : GateCommanderCP { using ports : gate : CommandOPT ; ticketCheck : TicketCheckIn ; faceCheck : FaceCheckIn ; } delegations : gate to gate ticket to ticket driver to driver } }
	component def GateCommanderCP { ports : gate : CommandOPT ; ticketCheck : TicketCheckIn ; faceCheck : FaceCheckIn ; }
	component def TicketCheckerCP { ports : ticket : TicketIPT ; ticketCheck : TicketCheckOut ; }
	component def FaceCheckerCP { ports : driver : DriverIPT ; faceCheck : FaceCheckOut ; } } Requirement ParkingControlFR ( 1 ) { text = "The system must control a parking lot." derive ParkingSpaceControlFR , ParkingEntranceControlFR , VehicleControlFR , PaymentControlFR ; } Requirement ParkingSpaceControlFR ( 1.1 ) { text = "The system must control the occupied spaces." satisfied by ParkingControlComponents.SpaceSensorCP , ParkingControlComponents.SpaceControllerCP ; derive ParkingSpaceIndicatorFR ; } Requirement ParkingEntranceControlFR ( 1.2 ) { text = "The system must control the parking gates." derive AutomaticGateControlFR , ManualGateControlFR ; } Requirement VehicleControlFR ( 1.3 ) { text = "The system must be able to identify the driver of the vehicle." satisfied by ParkingControlComponents.FaceRecognizerCP ; derive AssociationControlFR , AunteticityControlFR ; } Requirement PaymentControlFR ( 1.4 ) { text = "The system must be able to control payments for the time spent in the parking lot" derive CalculateValueFR , UpdateTariffFR ; } Requirement ParkingSpaceIndicatorFR ( 1.1.1 ) { text = "The system must be capable of indicating to the driver where and how much free stop the parking lot has" satisfied by ParkingControlComponents.SpaceIndicatorCP ; } Requirement ClearIndicationNFR ( 2.1 ) { text = "The system must indicate the spaces clearly for the driver" derive ParkingSpaceIndicatorFR ; } Requirement AutomaticGateControlFR ( 1.2.1 ) { text = "The system must be capable of control the gates automatically" satisfied by ParkingControlComponents.GateControllerCP ; derive TicketReadingFR ; } Requirement ManualGateControlFR ( 1.2.2 ) { text = "The system must allow for manual control of the gates." satisfied by ParkingControlComponents.GateControllerCP ; } Requirement TicketReadingFR ( 1.2.1.1 ) { text = "The system must be able to read printed tickets." satisfied by ParkingControlComponents.TicketReaderCP ; }   Requirement AunteticityControlFR ( 1.3.1 ) { text = "The system must authenticate a driver" satisfied by ParkingControlComponents.DriverControllerCP ; derive MultipleDriverControlFR ; } Requirement AssociationControlFR ( 1.3.2 ) { text = "The system must associate the entrance method with a vehicle" satisfied by ParkingControlComponents.DriverControllerCP , ParkingControlComponents.TicketReaderCP ; } Requirement MultipleDriverControlFR ( 1.3.1.1 ) { text = "The system must be able to add multiple authenticated drivers to a car" satisfied by ParkingControlComponents.DriverAppInterfaceCP ; } Requirement CalculateValueFR ( 1.4.1 ) { text = "The system must be able to calculate the value automatically" satisfied by ParkingControlComponents.PaymentControllerCP ; } Requirement CorrectnessNFR ( 2.5 ) { text = "The calculation algorithm must be correct" derive CalculateValueFR ; } Requirement UpdateTariffFR ( 1.4.2 ) { text = "The system must permit that a system administrator change the tariff of the parking lot" satisfied by ParkingControlComponents.PaymentControllerCP ; } Requirement ReadersPerformanceNFR ( 2.2 ) { text = "Any entrance reading must not exceed 10 seconds" derive TicketReadingFR ; } Requirement AuthorizedUseNFR ( 2.3 ) { text = "Only authorized people must use the manual control." derive ManualGateControlFR ; } Requirement SecurityNFR ( 2.4 ) { text = "It must garantee confidentiality, integrity and availability" derive PaymentControlFR , VehicleControlFR , ParkingEntranceControlFR ; } Requirement AvailabityNFR ( 2.5 ) { text = "The system must garantee availability and work ininterruptly" derive ParkingControlFR ; } package ParkingControlPorts { import SysADL.types ; port def TicketIPT { flow in Ticket } port def TicketOPT { flow out Ticket } port def CameraIPT { flow in String } port def CameraOPT { flow out String } port def PriceOPT { flow out Real } port def PriceIPT { flow in Real } port def CommandIPT { flow in Command } port def CommandOPT { flow out Command } port def ParkingSpotIPT { flow in ParkingSpot } port def ParkingSpotOPT { flow out ParkingSpot } port def SpotsIndicationIPT { flow in SpotIndication } port def SpotsIndicationOPT { flow out SpotIndication } port def DriverIPT { flow in Driver } port def DriverOPT { flow out Driver } port def PaymentIPT { flow in Payment } port def PaymentOPT { flow out Payment } port def TicketCheckIn { flow in Boolean port def TicketCheckIn { flow in Boolean } } port def TicketCheckOut { flow out Boolean } port def FaceCheckIn { flow in Boolean } port def FaceCheckOut { flow out Boolean } port def DriverINOUT { flow inout Driver } } package ParkingControlConnectors { import ParkingControlPorts ; connector def SendPlateCN { participants : ~ source : CameraOPT ; ~ destination : CameraIPT ; flows : String from source to destination } connector def SendCommandCN { participants : ~ source : CommandOPT ; ~ destination : CommandIPT ; flows : Command from source to destination } connector def PaymentCN { participants : ~ source : PaymentOPT ; ~ destination : PaymentIPT ; flows : Payment from source to destination } connector def DetectPresenceCN { participants : ~ source : ParkingSpotOPT ; ~ destination : ParkingSpotIPT ; flows : ParkingSpot from source to destination } connector def SendTicketCN { participants : ~ source : TicketOPT ; ~ destination : TicketIPT ; flows : Ticket from source to destination } connector def SendSpotsFreeAmountCN { participants : ~ source : SpotsIndicationOPT ; ~ destination : SpotsIndicationIPT ; flows : SpotIndication from source to destination } connector def SendDriverCN { participants : ~ source : DriverOPT ; ~ destination : DriverIPT ; flows : Driver from source to destination } connector def FaceCheckCN { participants : ~ destination : FaceCheckOut ; ~ source : FaceCheckIn ; flows : Boolean from source to destination } connector def TicketCheckCN { participants : ~ source : TicketCheckIn ; ~ destination : TicketCheckOut ; flows : Boolean from source to destination } }