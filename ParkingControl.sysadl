Model SysADLModel ; package SysADL.types { value type Int { } value type Boolean { } value type String { } value type Void { } value type Real { } enum PaymentOption { Cash , PIX , Debit , Credit , App } datatype Command { attributes : command : CommandGate ; } enum CommandGate { Open , Closed } value type DateTime { } datatype Ticket { attributes : vehicle : Vehicle ; entryTime : DateTime ; validatedUntil : DateTime ; status : PaymentStatus ; isActive : Boolean ; id : String ; } datatype Vehicle { attributes : plate : String ; driver : Driver ; isParked : Boolean ; } datatype Driver { attributes : id : String ; } enum PaymentStatus { PAID , NOT_PAID } datatype ParkingSpot { attributes : isParked : Boolean ; id : String ; isCovered : Boolean ; } datatype SpotIndication { attributes : spotsFree : Int ; spotsOccupied : Int ; } datatype Payment { attributes : ticket : Ticket ; id : String ; paymentOption : PaymentOption ; } } package ParkingControlComponents { import SysADL.types ; import ParkingControlPorts ; import ParkingControlConnectors ;
	component def PresenceSensorCP { ports : isParked : ParkingSpotOPT ; }
	component def SpaceIndicatorCP { ports :  spotsParked : SpotsIndicationIPT ; }  boundary
	component def GateCP { ports : gate : CommandIPT ; component def gateControllerCP { } }
	component def SpotController { ports : isParked : ParkingSpotIPT ; spotsParked : SpotsIndicationOPT ; }
	component def GateController { ports : cmdOPT : CommandOPT ; cmd : CommandIPT ; }
	component def ParkingController { ports : camera : CameraIPT ; cmd : CommandOPT ; plate : PlateOPT ; driver : DriverOPT ; }
	component def PaymentInterfaceCP { ports : po : PaymentOptionOPT ; ticket : TicketOPT ; price : PriceOPT ; }
	component def EntryInterfaceCP { }
	component def ExitInterfaceCP { } boundary
	component def TicketReaderCP { ports : tOPT : TicketOPT ; } boundary
	component def TicketEmiterCP { ports : tIPT : TicketIPT ; }
	component def TicketController { ports : driver : DriverIPT ; plate : PlateIPT ; ticket : TicketOPT ; }
	component def PaymentController { ports : ticket : TicketIPT ; po : PaymentOptionIPT ; price : PriceIPT ; }
	component def ParkingControl { configuration { components : Camera : CameraCP { using ports : camera : CameraOPT ; } PC : ParkingController { using ports : camera : CameraIPT ; cmd : CommandOPT ; plate : PlateOPT ; driver : DriverOPT ; } TC : TicketController { using ports : driver : DriverIPT ; plate : PlateIPT ; ticket : TicketOPT ; } GC : GateController { using ports : cmdOPT : CommandOPT ; cmd : CommandIPT ; } PayC : PaymentController { using ports : ticket : TicketIPT ; po : PaymentOptionIPT ; price : PriceIPT ; } SC : SpotController { using ports : isParked : ParkingSpotIPT ; spotsParked : SpotsIndicationOPT ; } EntryInterfaceCP : EntryInterfaceCP ; ExitInterfaceCP : ExitInterfaceCP ; PI : PaymentInterfaceCP { using ports : po : PaymentOptionOPT ; ticket : TicketOPT ; price : PriceOPT ; } GateCP : GateCP { using ports : gate : CommandIPT ; } TicketReaderCP : TicketReaderCP { using ports : tOPT : TicketOPT ; } TicketEmiterCP : TicketEmiterCP { using ports : tIPT : TicketIPT ; } SpaceIndicatorCP : SpaceIndicatorCP { using ports : spotsParked : SpotsIndicationIPT ; } PresenceSensorCP : PresenceSensorCP { using ports : isParked : ParkingSpotOPT ; } } }
	component def CameraCP { ports : camera : CameraOPT ; } } Requirement ParkingControlFR ( 1 ) { text = "The system must control a parking lot." derive ParkingSpaceControlFR , ParkingEntranceControlFR , VehicleControlFR , PaymentControlFR ; } Requirement ParkingSpaceControlFR ( 1.1 ) { text = "The system must control the occupied spaces." satisfied by ParkingControlComponents.PresenceSensorCP ; derive ParkingSpaceIndicatorFR ; } Requirement ParkingEntranceControlFR ( 1.2 ) { text = "The system must control the parking gates." derive AutomaticGateControlFR , ManualGateControlFR ; } Requirement VehicleControlFR ( 1.3 ) { text = "The system must be able to identify the driver of the vehicle." derive AssociationControlFR , AunteticityControlFR ; } Requirement PaymentControlFR ( 1.4 ) { text = "The system must be able to control payments for the time spent in the parking lot" derive CalculateValueFR , UpdateTariffFR ; } Requirement ParkingSpaceIndicatorFR ( 1.1.1 ) { text = "The system must be capable of indicating to the driver where and how much free stop the parking lot has" satisfied by ParkingControlComponents.SpaceIndicatorCP ; } Requirement ClearIndicationNFR ( 2.1 ) { text = "The system must indicate the spaces clearly for the driver" derive ParkingSpaceIndicatorFR ; } Requirement AutomaticGateControlFR ( 1.2.1 ) { text = "The system must be capable of control the gates automatically" derive TicketReadingFR ; } Requirement ManualGateControlFR ( 1.2.2 ) { text = "The system must allow for manual control of the gates." } Requirement TicketReadingFR ( 1.2.1.1 ) { text = "The system must be able to read printed tickets." }   Requirement AunteticityControlFR ( 1.3.1 ) { text = "The system must authenticate a driver" derive MultipleDriverControlFR ; } Requirement AssociationControlFR ( 1.3.2 ) { text = "The system must associate the entrance method with a vehicle" } Requirement MultipleDriverControlFR ( 1.3.1.1 ) { text = "The system must be able to add multiple authenticated drivers to a car" } Requirement CalculateValueFR ( 1.4.1 ) { text = "The system must be able to calculate the value automatically" } Requirement CorrectnessNFR ( 2.5 ) { text = "The calculation algorithm must be correct" derive CalculateValueFR ; } Requirement UpdateTariffFR ( 1.4.2 ) { text = "The system must permit that a system administrator change the tariff of the parking lot" } Requirement ReadersPerformanceNFR ( 2.2 ) { text = "Any entrance reading must not exceed 10 seconds" derive TicketReadingFR ; } Requirement AuthorizedUseNFR ( 2.3 ) { text = "Only authorized people must use the manual control." derive ManualGateControlFR ; } Requirement SecurityNFR ( 2.4 ) { text = "It must garantee confidentiality, integrity and availability" derive PaymentControlFR , VehicleControlFR , ParkingEntranceControlFR ; } Requirement AvailabityNFR ( 2.5 ) { text = "The system must garantee availability and work ininterruptly" derive ParkingControlFR ; } package ParkingControlPorts { import SysADL.types ; port def TicketIPT { flow in Ticket } port def TicketOPT { flow out Ticket } port def CameraIPT { flow in String } port def CameraOPT { flow out String } port def PriceOPT { flow out Real } port def PriceIPT { flow in Real } port def CommandIPT { flow in Command } port def CommandOPT { flow out Command } port def ParkingSpotIPT { flow in ParkingSpot } port def ParkingSpotOPT { flow out ParkingSpot } port def SpotsIndicationIPT { flow in SpotIndication } port def SpotsIndicationOPT { flow out SpotIndication } port def DriverIPT { flow in Driver } port def DriverOPT { flow out Driver } port def PaymentIPT { flow in Payment } port def PaymentOPT { flow out Payment } port def TicketCheckIn { flow in Boolean port def TicketCheckIn { flow in Boolean } } port def TicketCheckOut { flow out Boolean } port def FaceCheckIn { flow in Boolean } port def FaceCheckOut { flow out Boolean }  port def PaymentOptionIPT { flow in PaymentOption } port def PaymentOptionOPT { flow out PaymentOption } port def PlateIPT { flow in String } port def PlateOPT { flow out String } } package ParkingControlConnectors { import ParkingControlPorts ;  connector def SendCommandCN { participants : ~ source : CommandOPT ; ~ destination : CommandIPT ; flows : Command from source to destination } connector def PaymentCN { participants : ~ source : PaymentOPT ; ~ destination : PaymentIPT ; flows : Payment from source to destination } connector def DetectPresenceCN { participants : ~ source : ParkingSpotOPT ; ~ destination : ParkingSpotIPT ; flows : ParkingSpot from source to destination } connector def SendTicketCN { participants : ~ source : TicketOPT ; ~ destination : TicketIPT ; flows : Ticket from source to destination } connector def SendSpotsFreeAmountCN { participants : ~ source : SpotsIndicationOPT ; ~ destination : SpotsIndicationIPT ; flows : SpotIndication from source to destination } connector def SendDriverCN { participants : ~ source : DriverOPT ; ~ destination : DriverIPT ; flows : Driver from source to destination } connector def FaceCheckCN { participants : ~ destination : FaceCheckOut ; ~ source : FaceCheckIn ; flows : Boolean from source to destination } connector def TicketCheckCN { participants : ~ source : TicketCheckIn ; ~ destination : TicketCheckOut ; flows : Boolean from source to destination } connector def SendPriceCN { participants : ~ source : PriceOPT ; ~ dest : PriceIPT ; flows : Real from source to dest } connector def SendPlateCN { participants : ~ src : PlateOPT ; ~ src : PlateIPT ; flows : String from src to src } connector def SendCameraCN { participants : ~ src : CameraOPT ; ~ dest : CameraIPT ; flows : String from src to dest } }