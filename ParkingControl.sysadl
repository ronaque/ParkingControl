Model SysADLModel ; package SysADL.types { value type Int { } value type Boolean { } value type String { } value type Void { } value type Real { } enum PaymentOption { Cash , PIX , Debit , Credit , App } datatype Command { attributes : command : CommandGate ; } enum CommandGate { Open , Closed } value type DateTime { } datatype Ticket { attributes : vehicle : Vehicle ; entryTime : DateTime ; validatedUntil : DateTime ; status : PaymentStatus ; isActive : Boolean ; id : String ; } datatype Vehicle { attributes : plate : String ; driver : Driver ; isParked : Boolean ; } datatype Driver { attributes : id : String ; } enum PaymentStatus { PAID , NOT_PAID } datatype ParkingSpot { attributes : isParked : Boolean ; id : String ; isCovered : Boolean ; } datatype SpotsFree { attributes : spotsFree : Int ; } datatype Payment { attributes : ticket : Ticket ; id : String ; paymentOption : PaymentOption ; } } package ParkingControlComponents { import SysADL.types ; import ParkingControlPorts ; import ParkingControlConnectors ;
	component def SpaceSensorCP { ports : isParked : ParkingSpotOPT ; }
	component def SpaceIndicatorCP { ports : isParked : ParkingSpotIPT ; } boundary
	component def TicketReaderCP { } boundary
	component def RFIDReaderCP { } boundary
	component def LicensePlateReaderCP { } boundary
	component def GateCP { ports : gate : CommandIPT ; component def gateControllerCP { } }
	component def DriverControllerCP { }
	component def PaymentControllerCP { } component def DriverAppInterfaceCP { }
	component def FaceRecognizerCP { } component def ParkingControl { configuration { } } boundary
	component def CameraCP { ports : plate : CameraOPT ; } } Requirement ParkingControlFR ( 1 ) { text = "The system must control a parking lot." derive ParkingSpaceControlFR , ParkingEntranceControlFR , VehicleControlFR , PaymentControlFR ; } Requirement ParkingSpaceControlFR ( 1.1 ) { text = "The system must control the occupied spaces." satisfied by ParkingControlComponents.SpaceSensorCP ; derive ParkingSpaceIndicatorFR ; } Requirement ParkingEntranceControlFR ( 1.2 ) { text = "The system must control the parking gates." derive AutomaticGateControlFR , ManualGateControlFR ; } Requirement VehicleControlFR ( 1.3 ) { text = "The system must be able to identify the driver of the vehicle." satisfied by ParkingControlComponents.FaceRecognizerCP ; derive AssociationControlFR , AunteticityControlFR ; } Requirement PaymentControlFR ( 1.4 ) { text = "The system must be able to control payments for the time spent in the parking lot" derive CalculateValueFR , UpdateTariffFR ; } Requirement ParkingSpaceIndicatorFR ( 1.1.1 ) { text = "The system must be capable of indicating to the driver where and how much free stop the parking lot has" satisfied by ParkingControlComponents.SpaceIndicatorCP ; } Requirement ClearIndicationNFR ( 2.1 ) { text = "The system must indicate the spaces clearly for the driver" derive ParkingSpaceIndicatorFR ; } Requirement AutomaticGateControlFR ( 1.2.1 ) { text = "The system must be capable of control the gates automatically" satisfied by ParkingControlComponents.GateCP ; derive TicketReadingFR , RFIDReadingFR , LicensePlateReadingFR ; } Requirement ManualGateControlFR ( 1.2.2 ) { text = "The system must allow for manual control of the gates." satisfied by ParkingControlComponents.GateCP ; } Requirement TicketReadingFR ( 1.2.1.1 ) { text = "The system must be able to read printed tickets." satisfied by ParkingControlComponents.TicketReaderCP ; } Requirement RFIDReadingFR ( 1.2.1.2 ) { text = "The system must be able to read printed tickets." satisfied by ParkingControlComponents.RFIDReaderCP ; } Requirement LicensePlateReadingFR ( 1.2.1.3 ) { text = "The system must be able to read license plates." satisfied by ParkingControlComponents.LicensePlateReaderCP ; } Requirement AunteticityControlFR ( 1.3.1 ) { text = "The system must authenticate a driver" satisfied by ParkingControlComponents.DriverControllerCP ; derive MultipleDriverControlFR ; } Requirement AssociationControlFR ( 1.3.2 ) { text = "The system must associate the entrance method with a vehicle" satisfied by ParkingControlComponents.DriverControllerCP , ParkingControlComponents.TicketReaderCP , ParkingControlComponents.RFIDReaderCP , ParkingControlComponents.LicensePlateReaderCP ; } Requirement MultipleDriverControlFR ( 1.3.1.1 ) { text = "The system must be able to add multiple authenticated drivers to a car" satisfied by ParkingControlComponents.DriverAppInterfaceCP ; } Requirement CalculateValueFR ( 1.4.1 ) { text = "The system must be able to calculate the value automatically" satisfied by ParkingControlComponents.PaymentControllerCP ; } Requirement CorrectnessNFR ( 2.5 ) { text = "The calculation algorithm must be correct" derive CalculateValueFR ; } Requirement UpdateTariffFR ( 1.4.2 ) { text = "The system must permit that a system administrator change the tariff of the parking lot" satisfied by ParkingControlComponents.PaymentControllerCP ; } Requirement ReadersPerformanceNFR ( 2.2 ) { text = "Any entrance reading must not exceed 10 seconds" derive TicketReadingFR , RFIDReadingFR , LicensePlateReadingFR ; } Requirement AuthorizedUseNFR ( 2.3 ) { text = "Only authorized people must use the manual control." derive ManualGateControlFR ; } Requirement SecurityNFR ( 2.4 ) { text = "It must garantee confidentiality, integrity and availability" derive PaymentControlFR , VehicleControlFR , ParkingEntranceControlFR ; } Requirement AvailabityNFR ( 2.5 ) { text = "The system must garantee availability and work ininterruptly" derive ParkingControlFR ; } package ParkingControlPorts { import SysADL.types ; port def TicketIPT { flow in Ticket } port def TicketOPT { flow out Ticket } port def CameraIPT { flow in String } port def CameraOPT { flow out String } port def PriceOPT { flow out Real } port def PriceIPT { flow in Real } port def CommandIPT { flow in Command } port def CommandOPT { flow out Command } port def ParkingSpotIPT { flow in ParkingSpot } port def ParkingSpotOPT { flow out ParkingSpot } port def SpotsFreeIPT { flow in SpotsFree } port def SpotsFreeOPT { flow out SpotsFree } port def DriverIPT { flow in Driver } port def DriverOPT { flow out Driver } port def PaymentIPT { flow in Payment } port def PaymentOPT { flow out Payment } } package ParkingControlConnectors { import ParkingControlPorts ; connector def SendPlateCN { participants : ~ source : CameraOPT ; ~ destination : CameraIPT ; flows : String from source to destination } connector def SendCommandCN { participants : ~ source : CommandOPT ; ~ destination : CommandIPT ; flows : Command from source to destination } connector def PaymentCN { participants : ~ source : PaymentOPT ; ~ destination : PaymentIPT ; flows : Payment from source to destination } connector def DetectPresenceCN { participants : ~ source : ParkingSpotOPT ; ~ destination : ParkingSpotIPT ; flows : ParkingSpot from source to destination } connector def SendTicketCN { participants : ~ source : TicketOPT ; ~ destination : TicketIPT ; flows : Ticket from source to destination } connector def SendSpotsFreeAmountCN { participants : ~ source : SpotsFreeOPT ; ~ destination : SpotsFreeIPT ; flows : SpotsFree from source to destination } connector def SendDriverCN { participants : ~ source : DriverOPT ; ~ destination : DriverIPT ; flows : Driver from source to destination } }