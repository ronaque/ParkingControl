Model SysADLModel ; package SysADL.types { value type Int { } value type Boolean { } value type String { } value type Void { } value type Real { } enum PaymentOption { Cash , PIX , Debit , Credit , App } datatype Command { attributes : command : CommandGate ; } enum CommandGate { Open , Closed } value type DateTime { } datatype Ticket { attributes : vehicle : Vehicle ; entryTime : DateTime ; validatedUntil : DateTime ; status : PaymentStatus ; isActive : Boolean ; id : String ; } datatype Vehicle { attributes : plate : String ; driver : Driver ; isParked : Boolean ; } datatype Driver { attributes : id : String ; } enum PaymentStatus { PAID , NOT_PAID } datatype ParkingSpot { attributes : isParked : Boolean ; id : String ; isCovered : Boolean ; } datatype SpotIndication { attributes : spotsFree : Int ; spotsOccupied : Int ; } datatype Payment { attributes : ticket : Ticket ; id : String ; paymentOption : PaymentOption ; } datatype Camera { attributes : plate : String ; driver : Driver ; } constraint SumFreeSpotsEQ ( spot1eq2 : ParkingSpot , spot2eq2 : ParkingSpot ) : (  resulteq2 : Int ) { } constraint SumOccupiedSpotsEQ ( spot1eq1 : ParkingSpot , spot2eq1 : ParkingSpot ) : ( resulteq1 : Int ) { } action def SumSpotsAN ( spot1ac : ParkingSpot , spot2ac : ParkingSpot ) : SpotIndication { constraint : post-condition SumFreeSpotsEQ post-condition SumOccupiedSpotsEQ delegate spot1ac to spot1eq1 delegate spot1ac to spot1eq2 delegate spot2ac to spot2eq1 delegate spot2ac to spot2eq2 delegate SumSpotsAN to resulteq1 delegate SumSpotsAN to resulteq2 } activity def CalculateSpotIndicationAC ( spot1ac : ParkingSpot ) ( spot2ac : ParkingSpot ) : ( indication : SpotIndication ) { body { actions : SumSpotsAN : SumSpotsAN { using pins : spot1ac : ParkingSpot ; spot2ac : ParkingSpot ; } delegate spot1ac to spot1ac delegate spot2ac to spot2ac delegate indication to SumSpotsAN } } activity def ValidatePaymentAC ( payment : Payment ) ( tariff : Real ) : ( validation : Boolean ) { body { actions : CalculatePriceAN : CalculatePriceAN { using pins : entryDateTime : DateTime ; tariff : Real ; } CheckPayedPriceAN : CheckPayedPriceAN { using pins : calculatedPrice : Real ; payedPrice : Real ; } delegate payment to entryDateTime delegate tariff to tariff delegate payment to payedPrice flow from CalculatePriceAN to calculatedPrice delegate validation to CheckPayedPriceAN } } action def CheckPayedPriceAN ( calculatedPrice : Real , payedPrice : Real ) : Boolean { constraint : post-condition CheckPayedPriceEQ delegate calculatedPrice to calculatedPrice delegate payedPrice to payedPrice delegate CheckPayedPriceAN to result } action def CalculatePriceAN ( entryDateTime : DateTime , tariff : Real ) : Real { constraint : post-condition CalculatePriceEQ delegate entryDateTime to entryDateTime delegate tariff to tariff delegate CalculatePriceAN to price } constraint CalculatePriceEQ ( entryDateTime : DateTime , tariff : Real ) : ( price : Real ) { } constraint CheckPayedPriceEQ ( calculatedPrice : Real , payedPrice : Real ) : ( result : Boolean ) { } } package ParkingControlComponents { import SysADL.types ; import ParkingControlPorts ; import ParkingControlConnectors ;
	component def PresenceSensorCP { ports : isParked : ParkingSpotOPT ; }
	component def SpaceIndicatorCP { ports :  spotsParked : SpotsIndicationIPT ; }  boundary
	component def GateCP { ports : gate : CommandIPT ; component def gateControllerCP { } }
	component def SpotController { ports : isParked : ParkingSpotIPT ; spotsParked : SpotsIndicationOPT ; }
	component def GateController { ports : cmdOPT : CommandOPT ; cmd : CommandIPT ; }
	component def ParkingController { ports : camera : CameraIPT ; cmd : CommandOPT ;   ticketCheckI : TicketCheckIn ; driverI : DriverIPT ; plateI : PlateIPT ; }
	component def PaymentInterfaceCP { ports : po : PaymentOptionOPT ; ticket : TicketOPT ; priceOtp : PriceOPT ; paymentO : PaymentOPT ; } boundary
	component def TicketReaderCP { ports : tOPT : TicketOPT ; } boundary
	component def TicketEmiterCP { ports : tIPT : TicketIPT ; }
	component def TicketController { ports : driver : DriverOPT ; plate : PlateOPT ; ticket : TicketIPT ; ticketIO : TicketINOUT ; ticketCheckO : TicketCheckOut ; }
	component def PaymentController { ports : ticket : TicketIPT ; po : PaymentOptionIPT ; priceIpt : PriceIPT ; ticketInOut : TicketINOUT ; ticketOut : TicketOPT ; paymentI : PaymentIPT ; }
	component def ParkingControl { configuration { components : Cam : CameraCP { using ports : camera : CameraOPT ; }   GC : GateController { using ports : GCCmdOpt : CommandOPT ; GCCmdIpt : CommandIPT ; }  SC : SpotController { using ports : SCisParkedIpt : ParkingSpotIPT ; SCSpotsParkedOpt : SpotsIndicationOPT ; }    GateCP : GateCP { using ports : gate : CommandIPT ; } TR : TicketReaderCP { using ports : tOPT : TicketOPT ; } TE : TicketEmiterCP { using ports : tIPT : TicketIPT ; } SI : SpaceIndicatorCP { using ports : spotsParked : SpotsIndicationIPT ; } PS : PresenceSensorCP { using ports : isParked : ParkingSpotOPT ; } TC : TicketController { using ports : TCdriverI : DriverOPT ; TCplateI : PlateOPT ; TCticketI : TicketIPT ; TCticketIO : TicketINOUT ; TCticketCheckO : TicketCheckOut ; } PC : ParkingController { using ports : PCcameraI : CameraIPT ; PCcmdO : CommandOPT ; PCticketCheckI : TicketCheckIn ; PCdriverI : DriverIPT ; PCplateI : PlateIPT ; } PayC : PaymentController { using ports : PayCticketI : TicketIPT ; PayCpoI : PaymentOptionIPT ; PayCpriceIpt : PriceIPT ; PayCticketInOut : TicketINOUT ; PayCticketOut : TicketOPT ; PayCpaymentI : PaymentIPT ; } PI : PaymentInterfaceCP { using ports : PIpoO : PaymentOptionOPT ; PIticketO : TicketOPT ; PIpriceO : PriceOPT ; PIpaymentO : PaymentOPT ; } connectors : GCComandCN : SendCommandCN bindings GCCmdOpt = gate ;  PresIsParkedCN : DetectPresenceCN bindings isParked = SCisParkedIpt ; SCIndicationCN : SendSpotsFreeAmountCN bindings SCSpotsParkedOpt = spotsParked ; TRTicket : SendTicketCN bindings tOPT = TCticketI ; TCDriver : SendDriverCN bindings TCdriverI = PCdriverI ; TCPlate : SendPlateCN bindings TCplateI = PCplateI ; TCTicketCheck : TicketCheckCN bindings TCticketCheckO = PCticketCheckI ; CamCamera : SendCameraCN bindings camera = PCcameraI ; PCCommand : SendCommandCN bindings PCcmdO = GCCmdIpt ; PayCTicketO : SendTicketCN bindings PayCticketOut = tIPT ; PayCTCTicketIO : SendTicketCN bindings PayCticketInOut = TCticketIO ; PIPo : PaymentOptCN bindings PIpoO = PayCpoI ; PITicket : SendTicketCN bindings PIticketO = PayCticketI ; PIPrice : SendPriceCN bindings PIpriceO = PayCpriceIpt ; PIPayment : PaymentCN bindings PIpaymentO = PayCpaymentI ; } }
	component def CameraCP { ports : camera : CameraOPT ; } } Requirement ParkingControlFR ( 1 ) { text = "The system must control a parking lot." derive ParkingSpaceControlFR , ParkingEntranceControlFR , VehicleControlFR , PaymentControlFR ; } Requirement ParkingSpaceControlFR ( 1.1 ) { text = "The system must control the occupied spaces." satisfied by ParkingControlComponents.PresenceSensorCP ; derive ParkingSpaceIndicatorFR ; } Requirement ParkingEntranceControlFR ( 1.2 ) { text = "The system must control the parking gates." derive AutomaticGateControlFR , ManualGateControlFR ; } Requirement VehicleControlFR ( 1.3 ) { text = "The system must be able to identify the driver of the vehicle." derive AssociationControlFR , AunteticityControlFR ; } Requirement PaymentControlFR ( 1.4 ) { text = "The system must be able to control payments for the time spent in the parking lot" derive CalculateValueFR , UpdateTariffFR ; } Requirement ParkingSpaceIndicatorFR ( 1.1.1 ) { text = "The system must be capable of indicating to the driver where and how much free stop the parking lot has" satisfied by ParkingControlComponents.SpaceIndicatorCP ; } Requirement ClearIndicationNFR ( 2.1 ) { text = "The system must indicate the spaces clearly for the driver" derive ParkingSpaceIndicatorFR ; } Requirement AutomaticGateControlFR ( 1.2.1 ) { text = "The system must be capable of control the gates automatically" derive TicketReadingFR ; } Requirement ManualGateControlFR ( 1.2.2 ) { text = "The system must allow for manual control of the gates." } Requirement TicketReadingFR ( 1.2.1.1 ) { text = "The system must be able to read printed tickets." }   Requirement AunteticityControlFR ( 1.3.1 ) { text = "The system must authenticate a driver" derive MultipleDriverControlFR ; } Requirement AssociationControlFR ( 1.3.2 ) { text = "The system must associate the entrance method with a vehicle" } Requirement MultipleDriverControlFR ( 1.3.1.1 ) { text = "The system must be able to add multiple authenticated drivers to a car" } Requirement CalculateValueFR ( 1.4.1 ) { text = "The system must be able to calculate the value automatically" } Requirement CorrectnessNFR ( 2.5 ) { text = "The calculation algorithm must be correct" derive CalculateValueFR ; } Requirement UpdateTariffFR ( 1.4.2 ) { text = "The system must permit that a system administrator change the tariff of the parking lot" } Requirement ReadersPerformanceNFR ( 2.2 ) { text = "Any entrance reading must not exceed 10 seconds" derive TicketReadingFR ; } Requirement AuthorizedUseNFR ( 2.3 ) { text = "Only authorized people must use the manual control." derive ManualGateControlFR ; } Requirement SecurityNFR ( 2.4 ) { text = "It must garantee confidentiality, integrity and availability" derive PaymentControlFR , VehicleControlFR , ParkingEntranceControlFR ; } Requirement AvailabityNFR ( 2.5 ) { text = "The system must garantee availability and work ininterruptly" derive ParkingControlFR ; } package ParkingControlPorts { import SysADL.types ; port def TicketIPT { flow in Ticket } port def TicketOPT { flow out Ticket } port def CameraIPT { flow in Camera } port def CameraOPT { flow out Camera } port def PriceOPT { flow out Real } port def PriceIPT { flow in Real } port def CommandIPT { flow in Command } port def CommandOPT { flow out Command } port def ParkingSpotIPT { flow in ParkingSpot } port def ParkingSpotOPT { flow out ParkingSpot } port def SpotsIndicationIPT { flow in SpotIndication } port def SpotsIndicationOPT { flow out SpotIndication } port def DriverIPT { flow in Driver } port def DriverOPT { flow out Driver } port def PaymentIPT { flow in Payment } port def PaymentOPT { flow out Payment } port def TicketCheckIn { flow in Boolean port def TicketCheckIn { flow in Boolean } } port def TicketCheckOut { flow out Boolean }    port def PaymentOptionIPT { flow in PaymentOption } port def PaymentOptionOPT { flow out PaymentOption } port def PlateIPT { flow in String } port def PlateOPT { flow out String } port def TicketINOUT { flow inout Ticket } } package ParkingControlConnectors { import ParkingControlPorts ;  connector def SendCommandCN { participants : ~ source : CommandOPT ; ~ destination : CommandIPT ; flows : Command from source to destination } connector def PaymentCN { participants : ~ source : PaymentOPT ; ~ destination : PaymentIPT ; flows : Payment from source to destination } connector def DetectPresenceCN { participants : ~ source : ParkingSpotOPT ; ~ destination : ParkingSpotIPT ; flows : ParkingSpot from source to destination } connector def SendTicketCN { participants : ~ source : TicketOPT ; ~ destination : TicketIPT ; flows : Ticket from source to destination } connector def SendSpotsFreeAmountCN { participants : ~ source : SpotsIndicationOPT ; ~ destination : SpotsIndicationIPT ; flows : SpotIndication from source to destination } connector def SendDriverCN { participants : ~ source : DriverOPT ; ~ destination : DriverIPT ; flows : Driver from source to destination }  connector def TicketCheckCN { participants : ~ source : TicketCheckIn ; ~ destination : TicketCheckOut ; flows : Boolean from source to destination } connector def SendPriceCN { participants : ~ source : PriceOPT ; ~ dest : PriceIPT ; flows : Real from source to dest } connector def SendPlateCN { participants : ~ destination : PlateOPT ; ~ src : PlateIPT ; flows :  String from src to destination } connector def SendCameraCN { participants : ~ src : CameraOPT ; ~ dest : CameraIPT ; flows : String from src to dest } connector def PaymentOptCN { participants : ~ Source : PaymentOptionIPT ; ~ destination : PaymentOptionOPT ; flows : PaymentOption from Source to destination } }